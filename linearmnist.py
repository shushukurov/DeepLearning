# -*- coding: utf-8 -*-
"""LinearMNIST.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18x1Mf58Fd5NvajYi8zQLpzKSk1lJxLGX
"""

import torch
import torchvision
from torchvision import transforms, datasets

train = datasets.MNIST("",train=True,download=True,
                       transform=transforms.Compose([transforms.ToTensor()]))

test = datasets.MNIST("", train=False, download=True,
                      transform=transforms.Compose([transforms.ToTensor()]))

trainset = torch.utils.data.DataLoader(train, batch_size=10,shuffle=True)
testset = torch.utils.data.DataLoader(test,batch_size=10,shuffle=True)

for i in trainset:
  data = i
  break
import matplotlib.pyplot as plt
plt.imshow(data[0][1].view([28,28]))

counter_dict = {x:0 for x in range(10)}
total = 0
for data in trainset:
  Xs,Ys = data
  for i in Ys:
    counter_dict[int(i)]+=1
    total+=1
print(counter_dict)

import torch.nn as nn
import torch.nn.functional as F

class Net(nn.Module):
  def __init__(self):
    super(Net,self).__init__()
    self.fc1 = nn.Linear(28*28, 64)
    self.fc2 = nn.Linear(64, 64)
    self.fc3 = nn.Linear(64, 64)
    self.fc4 = nn.Linear(64, 10)

  def forward(self,x):
    x = F.relu(self.fc1(x))
    x = F.relu(self.fc2(x))
    x = F.relu(self.fc3(x))
    x = self.fc4(x)
    return F.log_softmax(x, dim=1)

net = Net()
print(net)
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
net.to(device)

import torch.optim as optim

optimizer = optim.Adam(net.parameters(), lr=0.001)

for epoch in range(3):

  for data in trainset:
    #data is batch of featuresets and labels
    X, y = data[0].to(device), data[1].to(device)
    net.zero_grad()
    output = net(X.view(-1,28*28))
    loss = F.nll_loss(output,y)
    loss.backward()
    optimizer.step()
  print(loss)

correct = 0
total = 0
with torch.no_grad():
  for data in testset:
    X,y = data[0].to(device), data[1].to(device)
    output = net(X.view(-1,28*28))
    for idx, i in enumerate(output):
      if torch.argmax(i) == y[idx]:
        correct +=1
      total +=1
print('Accuracy: ', round(correct/total,3))